<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>R2D2 + Asteroids + Buildings</title>
<style>
  body { margin: 0; overflow: hidden; }
  #info {
    position: absolute; top: 10px; left: 10px;
    z-index: 100; font-size: 20px;
    background: rgba(255,255,255,0.8); padding: 5px;
  }
</style>
</head>
<body>
<div id="info">Loading Scene...</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

<script>
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 25, 60);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 15, 0);
controls.update();

// Lights
scene.add(new THREE.AmbientLight(0x808080));
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(30,50,30);
dirLight.castShadow = true;
scene.add(dirLight);

// Ground
const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Dechachai05/model/main/grass.jpg');
groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(1,1);
const groundMat = new THREE.MeshStandardMaterial({ map: groundTexture, roughness:0.8, metalness:0.2 });
const groundGeo = new THREE.PlaneGeometry(50,50);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// 360Â° background
const texLoader = new THREE.TextureLoader();
texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/background1.jpg', function(texture){
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.background = texture;
});

// PBR textures for R2D2
const baseColorMap = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_baseColor.jpeg');
const emissiveMap  = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_emissive.jpeg');
const metallicRoughnessMap = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_metallicRoughness.png');
const normalMap    = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_normal.png');

let r2d2;

// Load OBJ + MTL
const mtlLoader = new THREE.MTLLoader();
mtlLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/r2d2.mtl', function(materials){
    materials.preload();

    const objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/r2d2.obj',
        function(object){
            object.traverse(function(child){
                if(child.isMesh){
                    child.material = new THREE.MeshStandardMaterial({
                        map: baseColorMap,
                        emissiveMap: emissiveMap,
                        metalnessMap: metallicRoughnessMap,
                        roughnessMap: metallicRoughnessMap,
                        normalMap: normalMap,
                        metalness: 1.0,
                        roughness: 1.0,
                        emissiveIntensity: 1.0
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Scale & position
            const bbox = new THREE.Box3().setFromObject(object);
            const maxDim = Math.max(...Object.values(bbox.getSize(new THREE.Vector3())));
            const scale = 20 / maxDim;
            object.scale.set(scale, scale, scale);
            const bboxScaled = new THREE.Box3().setFromObject(object);
            object.position.y -= bboxScaled.min.y;

            scene.add(object);
            r2d2 = object;
            document.getElementById('info').innerText = "R2D2 loaded!";
        }
    );
});

// Buildings
const buildingColors = [0xaaaaaa, 0x888888, 0x555555];
for(let i=0;i<3;i++){
    const width = Math.random()*3 + 2;
    const depth = Math.random()*3 + 2;
    const height = Math.random()*15 + 10;
    const geom = new THREE.BoxGeometry(width, height, depth);
    const mat = new THREE.MeshStandardMaterial({ color: buildingColors[i%buildingColors.length], roughness:0.7, metalness:0.1 });
    const building = new THREE.Mesh(geom, mat);
    building.position.set((i-1)*8, height/2, -10);
    building.castShadow = true;
    building.receiveShadow = true;
    scene.add(building);
}

// Asteroids
const asteroids = [];
function spawnAsteroid(){
    const radius = Math.random()*2 + 2;
    const geom = new THREE.SphereGeometry(radius,16,16);
    const mat = new THREE.MeshStandardMaterial({ color:0x553333, roughness:0.7, metalness:0.3 });
    const asteroid = new THREE.Mesh(geom, mat);
    asteroid.position.set((Math.random()-0.5)*40, 50, (Math.random()-0.5)*40);
    asteroid.userData.vel = new THREE.Vector3(0, -0.5-Math.random()*0.5, 0);
    scene.add(asteroid);
    asteroids.push(asteroid);
}

// Spawn initial asteroids
for(let i=0;i<5;i++) spawnAsteroid();

// Animation
function animate(){
    requestAnimationFrame(animate);

    asteroids.forEach((a)=>{
        a.position.add(a.userData.vel);

        // Collision with R2D2
        if(r2d2){
            const r2Box = new THREE.Box3().setFromObject(r2d2);
            const aBox = new THREE.Box3().setFromObject(a);
            if(r2Box.intersectsBox(aBox)){
                // Push asteroid to random side
                a.userData.vel.x = (Math.random()-0.5)*0.5;
                a.userData.vel.z = (Math.random()-0.5)*0.5;
                a.userData.vel.y = 0.3;
            }
        }

        // Remove if below ground
        if(a.position.y<-5){
            a.position.set((Math.random()-0.5)*40,50,(Math.random()-0.5)*40);
            a.userData.vel.set(0,-0.5-Math.random()*0.5,0);
        }
    });

    renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
