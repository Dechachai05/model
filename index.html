<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<title>R2D2 PBR + 360° Background + Big Meteors</title>
<style>
  body { margin: 0; overflow: hidden; }
  #info {
    position: absolute; top: 10px; left: 10px;
    z-index: 100; font-size: 20px;
    background: rgba(255,255,255,0.8); padding: 5px;
  }
</style>
</head>
<body>
<div id="info">Loading R2D2...</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

<script>
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 20, 60);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 15, 0);
controls.update();

scene.add(new THREE.AmbientLight(0x808080));
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(30,50,30);
dirLight.castShadow = true;
scene.add(dirLight);

// Ground
const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Dechachai05/model/main/grass.jpg');
groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(1,1);
const groundMat = new THREE.MeshStandardMaterial({ map: groundTexture, roughness:0.8, metalness:0.2 });
const groundGeo = new THREE.PlaneGeometry(50,50);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// 360° Background
const texLoader = new THREE.TextureLoader();
texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/background1.jpg', function(texture){
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.background = texture;
});

// PBR textures for R2D2
const baseColorMap = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_baseColor.jpeg');
const emissiveMap  = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_emissive.jpeg');
const metallicRoughnessMap = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_metallicRoughness.png');
const normalMap    = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_normal.png');

let r2d2 = null;

// Load R2D2 OBJ + MTL
const mtlLoader = new THREE.MTLLoader();
mtlLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/r2d2.mtl', function(materials){
    materials.preload();

    const objLoader = new THREE.OBJLoader();
    objLoader.setMaterials(materials);
    objLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/r2d2.obj',
        function(object){
            object.traverse(function(child){
                if(child.isMesh){
                    child.material = new THREE.MeshStandardMaterial({
                        map: baseColorMap,
                        emissiveMap: emissiveMap,
                        metalnessMap: metallicRoughnessMap,
                        roughnessMap: metallicRoughnessMap,
                        normalMap: normalMap,
                        metalness: 1.0,
                        roughness: 1.0,
                        emissiveIntensity: 1.0
                    });
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            const bbox = new THREE.Box3().setFromObject(object);
            const maxDim = Math.max(...Object.values(bbox.getSize(new THREE.Vector3())));
            const scale = 20 / maxDim;
            object.scale.set(scale, scale, scale);
            const bboxScaled = new THREE.Box3().setFromObject(object);
            object.position.y -= bboxScaled.min.y;

            scene.add(object);
            r2d2 = object;
            r2d2.bbox = new THREE.Box3().setFromObject(r2d2);

            document.getElementById('info').innerText = "R2D2 loaded with PBR textures!";
        }
    );
});

// Meteors
let meteors = [];
const meteorCount = 10;
for(let i=0;i<meteorCount;i++){
    const size = Math.random()*2 + 1; // big meteors
    const geom = new THREE.SphereGeometry(size, 16, 16);
    const mat = new THREE.MeshStandardMaterial({ color: 0x552200, metalness: 0.6, roughness: 0.8 });
    const meteor = new THREE.Mesh(geom, mat);
    meteor.position.set((Math.random()-0.5)*10, Math.random()*20 + 20, (Math.random()-0.5)*10);
    meteor.userData = { speed: Math.random()*0.3 + 0.1, rotationSpeed: Math.random()*0.05 };
    meteor.castShadow = true;
    meteor.receiveShadow = true;
    scene.add(meteor);
    meteors.push(meteor);
}

function animate(){
    requestAnimationFrame(animate);

    meteors.forEach(m=>{
        m.position.y -= m.userData.speed;
        m.rotation.x += m.userData.rotationSpeed;
        m.rotation.y += m.userData.rotationSpeed;

        // Collision with R2D2
        if(r2d2){
            r2d2.bbox.setFromObject(r2d2);
            const meteorBBox = new THREE.Box3().setFromObject(m);
            if(r2d2.bbox.intersectsBox(meteorBBox)){
                // กระเด้งออกข้าง
                m.position.y = r2d2.bbox.max.y + m.geometry.parameters.radius + 0.5;
                m.position.x += (Math.random()-0.5)*5;
                m.position.z += (Math.random()-0.5)*5;
            }
        }

        // If meteor below ground
        if(m.position.y < 0.5){
            m.position.y = Math.random()*20 + 20;
            m.position.x = (Math.random()-0.5)*10;
            m.position.z = (Math.random()-0.5)*10;
        }
    });

    renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

