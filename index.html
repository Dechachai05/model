<!DOCTYPE html>
<html>
<head>
    <title>R2D2 OBJ + PBR Textures</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute; top: 10px; left: 10px;
            z-index: 100; font-size: 20px;
            background: rgba(255,255,255,0.8); padding: 5px;
        }
    </style>
</head>
<body>
<div id="info">Loading R2D2...</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

<script>
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(30,20,60);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0,15,0);
controls.update();

// Lights
scene.add(new THREE.AmbientLight(0x808080));
const dirLight = new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(30,50,30);
dirLight.castShadow = true;
scene.add(dirLight);

// Ground
const groundTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Dechachai05/model/main/grass.jpg');
groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(1,1);
const groundMat = new THREE.MeshStandardMaterial({map:groundTexture, roughness:0.8, metalness:0.2});
const groundGeo = new THREE.PlaneGeometry(50,50);
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Background
scene.background = new THREE.TextureLoader().load('https://raw.githubusercontent.com/Dechachai05/model/main/background.jpg');

// Load R2D2 OBJ + PBR textures
const texLoader = new THREE.TextureLoader();
const baseColor = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_baseColor.jpeg');
const emissive = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_emissive.jpeg');
const metalRough = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_metallicRoughness.png');
const normalMap = texLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/SHD_R2R2_normal.png');

const objLoader = new THREE.OBJLoader();
objLoader.load('https://raw.githubusercontent.com/Dechachai05/model/main/r2d2.obj', (object)=>{
    object.traverse((child)=>{
        if(child.isMesh){
            child.material = new THREE.MeshStandardMaterial({
                map: baseColor,
                emissiveMap: emissive,
                metalnessMap: metalRough,
                roughnessMap: metalRough,
                normalMap: normalMap,
            });
            child.castShadow = true;
            child.receiveShadow = true;
        }
    });

    // Scale & position
    const bbox = new THREE.Box3().setFromObject(object);
    const maxDim = Math.max(...Object.values(bbox.getSize(new THREE.Vector3())));
    const scale = 20 / maxDim;
    object.scale.set(scale, scale, scale);
    const bboxScaled = new THREE.Box3().setFromObject(object);
    object.position.y -= bboxScaled.min.y;

    scene.add(object);
    document.getElementById('info').innerText = "R2D2 loaded with PBR textures!";
});

// Animate
function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

// Resize
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>
